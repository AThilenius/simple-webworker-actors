{"version":3,"sources":["../src/index.ts"],"sourcesContent":["type Fn = (...args: any) => any;\n\nconst threads: Worker[] = [];\nlet nextThread = 0;\nconst actorFunctions: { [key: string]: Fn } = {};\n\nexport function createLocalThreadPool(\n  webWorkerModule: new () => Worker,\n  count = 4\n) {\n  for (let i = 0; i < count; i++) {\n    threads.push(new webWorkerModule());\n  }\n}\n\nexport interface Actor<F extends Fn, R = ReturnType<F>, A = Awaited<R>> {\n  spawnRemote(...args: Parameters<F>): Promise<{\n    [Property in keyof A as A[Property] extends Fn\n      ? Property\n      : never]: A[Property] extends Fn\n      ? (\n          ...args: Parameters<A[Property]>\n        ) => Promise<Awaited<ReturnType<A[Property]>>>\n      : never;\n  }>;\n  spawnLocal(...args: Parameters<F>): R;\n}\n\nexport function Actor<F extends Fn>(actorId: string, f: F): Actor<F> {\n  registerActor(actorId, f);\n\n  return {\n    async spawnRemote(...args: any[]) {\n      // Get the next thread round-robin\n      if (!threads.length) {\n        throw new Error(\n          'Thread pool must be initialized with `createLocalThreadPool` first'\n        );\n      }\n\n      const thread = threads[nextThread];\n      nextThread = (nextThread + 1) % threads.length;\n\n      // Resolvers are local to an actor instance, because they use\n      // MessageChannels.\n      const resolvers: {\n        [callId: number]: {\n          resolve: (retVal: any) => void;\n          reject: (err: any) => void;\n        };\n      } = {};\n\n      // Spawn the actor remotely, send actor details, ctor args, and\n      // MessageChannel port it should us.\n      const { port1, port2 } = new MessageChannel();\n\n      // Send the port via transfer, see:\n      // https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects\n      const spawnEvent: ActorSpawnEvent = { actorId, args, port1 };\n      thread.postMessage(spawnEvent, [port1]);\n\n      // Wait for the first message to be received, it will always be the\n      // results of calling the actor itself.\n      await new Promise<void>((res, rej) => {\n        port2.onmessage = (event) => {\n          const data = event.data as ActorSpawnResult;\n          if (data.error) {\n            rej(data.error);\n          } else {\n            res();\n          }\n        };\n      });\n\n      // Handle the rest of the messages, which will all be call responses.\n      port2.onmessage = async (event) => {\n        const data = event.data as ActorResponseEvent;\n\n        // Find the resolver and complete it.\n        const resolver = resolvers[data.callId];\n        if (!resolver) {\n          console.error(\n            `Failed to find actor resolver for call ${data.callId}`\n          );\n          return;\n        }\n        if (data.error) {\n          resolver.reject(data.error);\n        } else {\n          resolver.resolve(data.response);\n        }\n\n        delete resolvers[data.callId];\n      };\n\n      // Finally, return an ES6 proxy that translates method calls into messages\n      // over the MessageChannel port2.\n      let nextCallId = 0;\n      return new Proxy(\n        {},\n        {\n          get(_target: any, propKey: string, _receiver: any) {\n            // Ignore await on the proxy itself.\n            if (propKey === 'then') {\n              return;\n            }\n\n            return function (...args: any[]) {\n              const callId = nextCallId++;\n              const reqEvent: ActorCallEvent = {\n                callId,\n                method: propKey,\n                args,\n              };\n\n              const promise = new Promise((resolve, reject) => {\n                resolvers[callId] = { resolve, reject };\n              });\n\n              port2.postMessage(reqEvent);\n\n              return promise;\n            };\n          },\n        }\n      );\n    },\n\n    spawnLocal(...args: any[]) {\n      return f(...args);\n    },\n  };\n}\n\nfunction registerActor(actorId: string, f: Fn) {\n  actorFunctions[actorId] = f;\n\n  // Also register the thread-local messages handler if it isn't already\n  // registered. This only handles actor spawn events, all other events are sent\n  // over a MessageChannel.\n  if (self.onmessage) {\n    return;\n  }\n\n  self.onmessage = async (event) => {\n    if (!event.isTrusted) {\n      return;\n    }\n\n    const data = event.data as ActorSpawnEvent;\n    const f = actorFunctions[data.actorId];\n\n    if (!f) {\n      console.error('No Actor named \"', data.actorId, '\" registered.');\n      return;\n    }\n\n    let actorMethods: any;\n    try {\n      actorMethods = await f(...data.args);\n    } catch (e) {\n      const result: ActorSpawnResult = { error: e };\n      data.port1.postMessage(result);\n      return;\n    }\n\n    // Handle inbound message on port1\n    data.port1.onmessage = async (event) => {\n      const call = event.data as ActorCallEvent;\n      const respEvent: ActorResponseEvent = {\n        callId: call.callId,\n        response: null,\n      };\n      try {\n        respEvent.response = await actorMethods[call.method].call(\n          actorMethods,\n          ...call.args\n        );\n      } catch (e) {\n        respEvent.error = e;\n      }\n      data.port1.postMessage(respEvent);\n    };\n\n    // All done\n    data.port1.postMessage({});\n  };\n}\n\ninterface ActorSpawnEvent {\n  actorId: string;\n  args: any[];\n  port1: MessagePort;\n}\n\ninterface ActorSpawnResult {\n  error?: any;\n}\n\ninterface ActorCallEvent {\n  callId: number;\n  method: string;\n  args: any[];\n}\n\ninterface ActorResponseEvent {\n  callId: number;\n  response: any;\n  error?: any;\n}\n"],"mappings":"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","names":[]}